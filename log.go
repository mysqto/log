// Copyright (c) 2019 Chen Lei <my@mysq.to>. All rights reserved.
// Copyright (c) 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Package log implements a simple logging package. It defines a type, Logger,
// with methods for formatting output. It also has a predefined 'standard'
// Logger accessible through helper functions Print[f|ln], Fatal[f|ln], and
// Panic[f|ln], which are easier to use than creating a Logger manually.
// That logger writes to standard error and prints the date and time
// of each logged message.
// Every log message is output on a separate line: if the message being
// printed does not end in a newline, the logger will add one.
// The Fatal functions call os.Exit(1) after writing the log message.
// The Panic functions call panic after writing the log message.
package log

import (
	"io"
	"os"
	"sync"
	"sync/atomic"
	"time"
)

// Level log level
type Level uint32

// supported levels
const (
	none Level = iota
	FATAL
	ERROR
	WARN
	INFO
	DEBUG
)

var (
	logger atomic.Value // holds current server configuration
	levels = map[Level]string{
		none:  "",
		FATAL: "FATAL",
		ERROR: "ERROR",
		WARN:  " WARN",
		INFO:  " INFO",
		DEBUG: "DEBUG",
	}
)

// These flags define which text to prefix to each log entry generated by the Logger.
// Bits are or'ed together to control what's printed.
// There is no control over the order they appear (the order listed
// here) or the format they present (as described in the comments).
// The prefix is followed by a colon only when Llongfile or Lshortfile
// is specified.
// For example, flags Ldate | Ltime (or LstdFlags) produce,
//	2009/01/23 01:23:23 message
// while flags Ldate | Ltime | Lmicroseconds | Llongfile produce,
//	2009/01/23 01:23:23.123123 /a/b/c/d.go:23: message
const (
	Ldate         = 1 << iota     // the date in the local time zone: 2009/01/23
	Ltime                         // the time in the local time zone: 01:23:23
	Lmicroseconds                 // microsecond resolution: 01:23:23.123123.  assumes Ltime.
	Llongfile                     // full file name and line number: /a/b/c/d.go:23
	Lshortfile                    // final file name element and line number: d.go:23. overrides Llongfile
	LUTC                          // if Ldate or Ltime is set, use UTC rather than the local time zone
	Lloggername                   // logger name, Logger.name if empty use process name
	Lgoroutineid                  // current goroutine id from the runtime stack which will cause significant performance reduction, do not use it unless you must
	Llongfunc                     // long function name with vendor & package: github.com/mysqto/golog.(*.Logger).printf
	Lshortfunc                    // short function name: printf
	Lsequence                     // write log sequence id
	Lcolor                        // colorful log when output is tty
	LstdFlags     = Ldate | Ltime // initial values for the standard logger
	Lfull         = Ldate | Ltime | Lmicroseconds | Lshortfile | Lloggername /*| Lgoroutineid*/ | Lshortfunc | Lsequence | Lcolor
)

// A Logger represents an active logging object that generates lines of
// output to an io.Writer. Each logging operation makes a single call to
// the Writer's Write method. A Logger can be used simultaneously from
// multiple goroutines; it guarantees to serialize access to the Writer.
type Logger struct {
	index   uint64     // log entry index
	level   Level      // log level
	mu      sync.Mutex // ensures atomic writes; protects the following fields
	prefix  string     // prefix to write at beginning of each line
	flag    int        // properties
	backend Backend    // default destination for output
	name    string     // logger name if empty use process name
}

// New creates a new Logger. The out variable sets the
// destination to which log data will be written.
// The prefix appears at the beginning of each generated log line.
// The flag argument defines the logging properties.
func New(out io.Writer, prefix string, flag int) *Logger {

	var name string

	if flag&Lloggername > 0 {
		name = procName()
	}

	log := &Logger{
		backend: NewSyncBackend(out),
		prefix:  prefix,
		flag:    flag,
		name:    name,
		level:   DEBUG,
	}
	logger.Store(log)
	return log
}

// std returns the standard logger
func std() *Logger {
	log := logger.Load()
	if log != nil {
		return log.(*Logger)
	}
	return New(os.Stderr, "", Lfull)
}

// Writer returns the output destination for the logger.
func (l *Logger) Writer() io.Writer {
	l.mu.Lock()
	defer l.mu.Unlock()
	return l.backend.Writer()
}

// SetOutput sets the output destination for the logger.
func (l *Logger) SetOutput(w io.Writer) {
	l.mu.Lock()
	defer l.mu.Unlock()
	l.backend.SetWriter(w)
}

// Name returns the name of current logger
func (l *Logger) Name() string {
	l.mu.Lock()
	defer l.mu.Unlock()
	return l.name
}

// SetName sets the name for the logger.
func (l *Logger) SetName(name string) {
	l.mu.Lock()
	defer l.mu.Unlock()
	l.name = name
}

// Level returns current level of logger
func (l *Logger) Level() Level {
	return Level(atomic.LoadUint32((*uint32)(&l.level)))
}

// SetLogLevel update the logger's level
func (l *Logger) SetLogLevel(level Level) {
	atomic.StoreUint32((*uint32)(&l.level), uint32(level))
}

// Flags returns the output flags for the logger.
func (l *Logger) Flags() int {
	l.mu.Lock()
	defer l.mu.Unlock()
	return l.flag
}

// SetFlags sets the output flags for the logger.
func (l *Logger) SetFlags(flag int) {
	l.mu.Lock()
	defer l.mu.Unlock()
	l.flag = flag
}

// Prefix returns the output prefix for the logger.
func (l *Logger) Prefix() string {
	l.mu.Lock()
	defer l.mu.Unlock()
	return l.prefix
}

// SetPrefix sets the output prefix for the logger.
func (l *Logger) SetPrefix(prefix string) {
	l.mu.Lock()
	defer l.mu.Unlock()
	l.prefix = prefix
}

// Output writes the output for a logging event. The string s contains
// the text to print after the prefix specified by the flags of the
// Logger. A newline is appended if the last character of s is not
// already a newline. Calldepth is used to recover the PC and is
// provided for generality, although at the moment on all pre-defined
// paths it will be 2.
func (l *Logger) Output(calldepth int, s string) error {
	l.output(calldepth, none, writeModeLog, nil, s)
	return nil
}

func (l *Logger) output(calldepth int, level Level, mode writeMode, format *string, v ...interface{}) {
	now := time.Now() // get this early.
	var file, function string
	var line int
	l.mu.Lock()
	defer l.mu.Unlock()
	if l.flag&(Lshortfile|Llongfile|Lshortfunc|Llongfunc) != 0 {
		// Release lock while getting caller info - it's expensive.
		function, file, line = getRuntimeInfo(calldepth)
	}

	r := &Record{
		index:    l.index,
		time:     now,
		prefix:   &l.prefix,
		module:   &l.name,
		level:    level,
		file:     &file,
		line:     line,
		function: &function,
		fmt:      format,
		args:     v,
		flag:     l.flag,
		mode:     mode,
		newline:  true,
	}

	l.backend.log(r)
	l.updateLogIndex()
}

func (l *Logger) log(level Level, v ...interface{}) {
	if level <= Level(atomic.LoadUint32((*uint32)(&l.level))) {
		l.output(4, level, writeModeLog, nil, v...)
	}
}

func (l *Logger) logf(level Level, format string, v ...interface{}) {
	if level <= Level(atomic.LoadUint32((*uint32)(&l.level))) {
		l.output(4, level, writeModeLogf, &format, v...)
	}
}

func (l *Logger) logln(level Level, v ...interface{}) {
	if level <= Level(atomic.LoadUint32((*uint32)(&l.level))) {
		l.output(4, level, writeModeLogln, nil, v...)
	}
}

// updateLogIndex updates current logger index
func (l *Logger) updateLogIndex() {
	atomic.AddUint64(&l.index, 1)
}

// logIndex load current index
func (l *Logger) logIndex() uint64 {
	return atomic.LoadUint64(&l.index)
}

// Debug prints debug log.
func (l *Logger) Debug(v ...interface{}) {
	l.log(DEBUG, v...)
}

// Debugln prints debug log with newline.
func (l *Logger) Debugln(v ...interface{}) {
	l.logln(DEBUG, v...)
}

// Debugf prints formatted debug log.
func (l *Logger) Debugf(format string, v ...interface{}) {
	l.logf(DEBUG, format, v...)
}

// Info prints info log.
func (l *Logger) Info(v ...interface{}) {
	l.log(INFO, v...)
}

// Infoln prints info log with newline.
func (l *Logger) Infoln(v ...interface{}) {
	l.logln(INFO, v...)
}

// Infof prints formatted info log.
func (l *Logger) Infof(format string, v ...interface{}) {
	l.logf(INFO, format, v...)
}

// Warn prints warning log.
func (l *Logger) Warn(v ...interface{}) {
	l.log(WARN, v...)
}

// Warnln prints warning log with newline.
func (l *Logger) Warnln(v ...interface{}) {
	l.logln(WARN, v...)
}

// Warnf prints formatted warning log.
func (l *Logger) Warnf(format string, v ...interface{}) {
	l.logf(WARN, format, v...)
}

// Error prints error log.
func (l *Logger) Error(v ...interface{}) {
	l.log(ERROR, v...)
}

// Errorln prints error log with newline.
func (l *Logger) Errorln(v ...interface{}) {
	l.logln(ERROR, v...)
}

// Errorf prints formatted error log.
func (l *Logger) Errorf(format string, v ...interface{}) {
	l.logf(ERROR, format, v...)
}

// Fatal prints fatal log and exit current process.
func (l *Logger) Fatal(v ...interface{}) {
	l.log(FATAL, v...)
}

// Fatalln prints fatal log with newline and exit current process.
func (l *Logger) Fatalln(v ...interface{}) {
	l.logln(FATAL, v...)
}

// Fatalf prints formatted fatal log and exit current process.
func (l *Logger) Fatalf(format string, v ...interface{}) {
	l.logf(FATAL, format, v...)
}

// Print calls Output to print to the standard logger.
// Arguments are handled in the manner of fmt.Print.
func (l *Logger) Print(v ...interface{}) {
	l.output(3, none, writeModeLog, nil, v...)
}

// Printf calls Output to print to the standard logger.
// Arguments are handled in the manner of fmt.Printf.
func (l *Logger) Printf(format string, v ...interface{}) {
	l.output(3, none, writeModeLogf, &format, v...)
}

// Println calls Output to print to the standard logger.
// Arguments are handled in the manner of fmt.Println.
func (l *Logger) Println(v ...interface{}) {
	l.output(3, none, writeModeLogln, nil, v...)
}

// Flush flush current logger
func (l *Logger) Flush() {
	l.backend.Flush()
}

// These functions write to the standard logger.

// Writer returns the output destination for the std logger.
func Writer() io.Writer {
	return std().Writer()
}

// SetOutput sets the output destination for the std logger.
func SetOutput(w io.Writer) {
	std().SetOutput(w)
}

// Name returns the name of the std logger
func Name() string {
	return std().Name()
}

// SetName sets the name for the std logger.
func SetName(name string) {
	std().SetName(name)
}

// SetLogLevel update the std logger level
func SetLogLevel(level Level) {
	std().SetLogLevel(level)
}

// Flags returns the output flags for std logger.
func Flags() int {
	return std().Flags()
}

// SetFlags sets the output flags for the logger.
func SetFlags(flag int) {
	std().SetFlags(flag)
}

// Prefix returns the output prefix for the std logger.
func Prefix() string {
	return std().Prefix()
}

// SetPrefix sets the output prefix for the std logger.
func SetPrefix(prefix string) {
	std().SetPrefix(prefix)
}

// Debug prints debug log.
func Debug(v ...interface{}) {
	std().log(DEBUG, v...)
}

// Debugln prints debug log with newline.
func Debugln(v ...interface{}) {
	std().logln(DEBUG, v...)
}

// Debugf prints formatted debug log.
func Debugf(format string, v ...interface{}) {
	std().logf(DEBUG, format, v...)
}

// Info prints info log.
func Info(v ...interface{}) {
	std().log(INFO, v...)
}

// Infoln prints info log with newline.
func Infoln(v ...interface{}) {
	std().logln(INFO, v...)
}

// Infof prints formatted info log.
func Infof(format string, v ...interface{}) {
	std().logf(INFO, format, v...)
}

// Warn prints warning log.
func Warn(v ...interface{}) {
	std().log(WARN, v...)
}

// Warnln prints warning log with newline.
func Warnln(v ...interface{}) {
	std().logln(WARN, v...)
}

// Warnf prints formatted warning log.
func Warnf(format string, v ...interface{}) {
	std().logf(WARN, format, v...)
}

// Error prints error log.
func Error(v ...interface{}) {
	std().log(ERROR, v...)
}

// Errorln prints error log with newline.
func Errorln(v ...interface{}) {
	std().logln(ERROR, v...)
}

// Errorf prints formatted error log.
func Errorf(format string, v ...interface{}) {
	std().logf(ERROR, format, v...)
}

// Fatal prints fatal log and exit current process.
func Fatal(v ...interface{}) {
	std().log(FATAL, v...)
}

// Fatalln prints fatal log with newline and exit current process.
func Fatalln(v ...interface{}) {
	std().logln(FATAL, v...)
}

// Fatalf prints formatted fatal log and exit current process.
func Fatalf(format string, v ...interface{}) {
	std().logf(FATAL, format, v...)
}

// Print calls Output to print to the standard logger.
// Arguments are handled in the manner of fmt.Print.
func Print(v ...interface{}) {
	std().output(3, none, writeModeLog, nil, v...)
}

// Printf calls Output to print to the standard logger.
// Arguments are handled in the manner of fmt.Printf.
func Printf(format string, v ...interface{}) {
	std().output(3, none, writeModeLogf, &format, v...)
}

// Println calls Output to print to the standard logger.
// Arguments are handled in the manner of fmt.Println.
func Println(v ...interface{}) {
	std().output(3, none, writeModeLogln, nil, v...)
}

// Flush std logger
func Flush() {
	std().backend.Flush()
}

func writeLog(backend Backend, r *Record) {
	if r.flag&Lcolor != 0 {
		if backend.isatty() {
			r.colorfultty(backend, false)
		} else {
			r.colorful(backend, false)
		}
	} else {
		_ = backend.write(r.msgBuf())
	}

	if r.level == FATAL {
		os.Exit(1)
	}
}
